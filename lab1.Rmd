---
title: "Lab1"
output: html_document
date: "2023-11-01"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Computational Statistics 732A90 - Fall 23
# Computer Lab 1

### Hugo Morvan, Daniele Bozzoli

## Question 1

### a)
Plot of the Likelyhood function :
```{r echo=FALSE, message=FALSE, warning=FALSE}
library("ggplot2")
log_likelyhood <- function(x){
  vec <- c(-2.8, 3.4, 1.2, -0.3, -2.6)
  n <- 5
  sum_el <- 0
  for(el in vec){
    sum_el <- sum_el + log(1+ (el - x)^2)
  }
  res <- -n*log(pi) - sum_el
  return(res)
}
ggplot(data.frame(x=c(-4, 4)), aes(x=x)) + 
  stat_function(fun=log_likelyhood) +
  geom_vline(xintercept = -2.082124)

```

Plot of the first derivative of the likelyhood function
```{r echo=FALSE}
first_derivative <- function(theta){
  vec <- c(-2.8, 3.4, 1.2, -0.3, -2.6)
  n <- 5
  sum_res <- 0
  for(i in vec){
    sum_res <- sum_res + 2*(i-theta)/(1+(i-theta)^2)
  }
  res <- sum_res
  return(res)
}
ggplot(data.frame(x=c(-4, 4)), aes(x=x)) + 
  stat_function(fun=first_derivative)

```

From this plot, we can see that the first derivative is equal to 0 in three locations

### b)

```{r echo=FALSE}
bisection <- function(a,b, fun, acc){
  if( fun(a)*fun(b) >= 0 ){
    stop("Choose better boundaries")
  }
  t <- 0
  
  while(round(a, acc) != round(b, acc)){
    mid <- (a+b)/2
    t <- t+1
    gp_a <- fun(a)
    gp_mid <- fun(mid)
    gp_b <- fun(b)
    if(gp_a * gp_mid <=0){
      b <- mid
    }
    else{
      a <- mid
    }
  }
  #cat("t:", t, "\n")
  return(a)
}
```

### c)
```{r local extremum 1, echo=FALSE}
bisection(-3, -2, first_derivative, 9)
```

```{r local extremum 2, echo=FALSE}
bisection(-2, -1, first_derivative, 9)
```

```{r local extremum 3, echo=FALSE}
bisection(-1, 0, first_derivative, 9)
```

We can check our result by adding the X values on the graph
```{r echo=FALSE}
ggplot(data.frame(x=c(-4, 4)), aes(x=x)) + 
  stat_function(fun=first_derivative) +
  geom_vline(xintercept = -2.082124) +
  geom_vline(xintercept = -1.601775) +
  geom_vline(xintercept = -0.2952455)

```

```{r echo=FALSE}
print("first intercept")
log_likelyhood(-2.082124)
print("second intercept")
log_likelyhood(-1.601775)
print("third intercept")
log_likelyhood(-0.2952455)
```
 Based on the computation, the third local optima is the global maximum
 
```{r echo=FALSE}
bisection(-4, 4, first_derivative, 9)
```
  If our starting interval contains several local optima, it is not guaranteed that the bisection method finds the local maximum of that interval. 

### d)

Pseudo-code to find all the local optima given a wide starting range [A,B] containing several optima.
Step 1: set left boundary a to A, the left limit of our range. Set right boundary b to be slightly bigger than A such that the stopping condition of our while loop is not met (i.e. a != b, but very close)
Step 2: Calculate f'(a)*f'(b). If the result is positive, increase the value of b until the result becomes negative. Once the result is negative, run the bisection function to find the optima and store it in a vector.
Step 3: set the left boundary to be b (the previous right boundary)
Step 4: Repeat steps 1,2,3 until the right boundary reaches the value of B, the end of our range. You should have found all of the optima between A and B.
Step 5: Find the global maximum by comparing the values of the candidates in the vector into the original function f(x).

## Question 2

### a)

```{r echo=FALSE}
myvar <- function(vector){
  n <- length(vector)
  var1 <- (1/(n-1))*(sum(vector^2)-(1/n)*(sum(vector))^2)
  return(var1)
}
```

### b)

```{r echo=FALSE}
set.seed(69)
vectorx <- rnorm(1E4, 1E8, 1)
```

### c)

```{r echo=FALSE}
Y <- rep(0,1E4)
for (q in 2:1E4){
  Y[q] <- myvar(vectorx[1:q]) - var(vectorx[1:q])
}
plot(Y)
```

The myvar function does not work well for vectors with large mean ( >= 10^7 ).
The myvar functions gives good estimations with vectors of observations coming 
from a Normal distribution until we get random values from N distributions with
mean >= 10^7. The problem comes from the computation of the sum in the myvar function: Since our mean is 10^8 and we have up to 10^4 elements in the vector, the sum can get as big as 10^12 which is greater than the maximum value for integers in R which is ~2*10^9. We therefore run into a stack overflow issue which completely breaks our function. This problem is avoided for smaller means as the overflow limit is not reach when calculating the sums.










