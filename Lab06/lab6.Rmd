---
title: "Lab 6"
author: "Hugo Morvan, Daniele Bozzoli"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Question 1: Genetic algorithm
In this assignment, you will try to solve the n–queen problem using a genetic algorithm. Given an n by n chessboard, the task is to place n queens on it so that no queen is attacked by any other queen. You can read more about the problem at https://en.wikipedia.org/wiki/Eight_queens_puzzle.

### 1. 

An individual in the population is a chessboard with some placement of the n queens on it. The first task is to code an individual. You are to consider three encodings for this question.

* (a) A collection (e.g., a list—but the choice of data structure is up to you) of n pairs denoting the coordinates of each queen, e.g., (5, 6) would mean that a queen is standing in row 5 and column 6.

```{r 1.1.a}
#1.1.a 
# Pairs representing the coordinates of each queen, stored in a matrix
# Representation_type = "pairs"
n <- 5
pairs <- matrix(nrow = n, ncol = 2)
for (i in 1:n){
  pairs[i,] <- sample(1:n, 2)
}
typeof(pairs) #integer
ncol(pairs) #2
print(pairs)
```

* (b) On n numbers, where each number has log2 n binary digits—this number encodes the position of the queen in the given column. Notice that as queens cannot attack each other, in a legal configuration there can be only one queen per column. You can pad your binary representation with 0s if necessary.

```{r 1.1.b}
#1.1.b
# A list of n numbers, where each number is a binary representation of the position of the queen 
# in the given column
# Representation_type = "binary"
n <- 5
binary <- list()
for (i in 1:n){
  binary[[i]] <- c(as.integer(intToBits(sample(1:n, 1))))
}
typeof(binary) #list
ncol(binary) #NULL
print(binary)

```

*(c) On n numbers, where each number is the row number of the queen in each column. Notice that this encoding differs from the previous one by how the row position is stored. Here it is an integer, in item 1b it was represented through its binary representation. This will induce different ways of crossover and mutating the state.


```{r 1.1.c}
#1.1.c
# A list of n numbers, where each number is the row number of the queen in each column
# Representation_type = "singles"
n <- 5

row <- c()
for (i in 1:n){
  row[i] <- sample(1:n, 1)
}
typeof(row) #integer
ncol(row) #NULL
print(row)
```
The tasks below, 2–7 are to be repeated for each of the three encodings above.

```{r}
vizualize_board <- function(layout, n){
  #Given a layout, vizualizes the board
  #cat("Type of layout", typeof(layout), "\n", "Number of columns", ncol(layout), "\n")
  if(typeof(layout) == "list" & is.null(ncol(layout))){
    #Binary
    print("Viz: Binary rep detected")
    #Idea: create a matrix of 0s, then replace the 0s with 1s where the queens are
    board <- matrix(nrow = n, ncol = n)
    #fill the board with 0s
    for (i in 1:nrow(board)){
      for (j in 1:ncol(board)){
        board[i,j] <- 0
      }
    }
    for (i in 1:n){
      for (j in 1:length(layout[[i]])){
        if(layout[[i]][j] == 1){
          board[i,j] <- 1
        }
      }
    }
    board <- t(board)
    #print(board)
  }else if(typeof(layout) == "integer" & is.null(ncol(layout))){
    #Singles
    print("Viz: Singles rep detected")
    #Idea: create a matrix of 0s, then replace the 0s with 1s where the queens are
    board <- matrix(nrow = n, ncol = n)
    #fill the board with 0s
    for (i in 1:nrow(board)){
      for (j in 1:ncol(board)){
        board[i,j] <- 0
      }
    }
    for (i in 1:n){
      board[i,layout[i]] <- 1
    }
    board <- t(board)
    #print(board)
  }else if(typeof(layout) == "integer" & ncol(layout) == 2){
    #Pairs
    print("Viz: Pairs rep detected")
    #IDea: create a matrix of 0s, then replace the 0s with 1s where the queens are
    board <- matrix(nrow = n, ncol = n)
    #fill the board with 0s
    for (i in 1:nrow(board)){
      for (j in 1:ncol(board)){
        board[i,j] <- 0
      }
    }
    for (i in 1:nrow(layout)){
      board[layout[i,1], layout[i,2]] <- 1
    }
    #print(board)
  }
  #Print the board in the console:
  for (i in 1:nrow(board)){
    cat("|")
    for (j in 1:ncol(board)){
      if(board[i,j] == 0){
        cat(" |")
      }else{
        cat("Q|")
      }
    }
    cat("\n")
  }
}
# pairs
# vizualize_board(pairs, 5)
# binary
# vizualize_board(binary, 5)
# row
# vizualize_board(row ,5)
```

### 2. 

Define the function crossover(): for two chessboard layouts it creates a kid by taking columns 1,..., p from the first individual and columns p + 1,..., n from the second. Obviously, 0 < p <= n/2, and p in N. Experiment with different values of p.

```{r 1.2}
#1.2

crossover <- function(layout1, layout2, p){
  #Given 2 chessboard layouts, returns a kid by taking columns 1,..., p from the first individual and columns p + 1,..., n from the second.
  if(typeof(layout1) == "list" & is.null(ncol(layout1))){
    #BINARY (one binary rep = one column)
    print("Cross: Binary rep detected")
    #Idea: take the first p columns from layout 1 and adds them to the kid, then take the last n-p colmuns from layout 2 and adds them to the kid
    kid <- list()
    for (i in 1:p){
      kid[[i]] <- layout1[[i]]
    }
    for (i in (p+1):length(layout2)){
      kid[[i]] <- layout2[[i]]
    }
    
    return(kid)
  }
  else if(typeof(layout1) == "integer" & is.null(ncol(layout1))){
    #SINGLES
    print("Cross: Singles rep detected")
    #Take the first p number from layout 1 and adds them to the kid, then take the last n-p numbers from layout 2 and adds them to the kid
    kid <- c()
    for (i in 1:p){
      kid <- c(kid , layout1[i])
    }
    for (i in (p+1):length(layout2)){
      kid <- c(kid , layout2[i])
    }
    return(kid)
  }else if(typeof(layout1) == "integer" & ncol(layout1) == 2){
    #PAIRS (matrix)
    print("Cross: Pairs rep detected")
    #Idea : for layout1 and layout 2, take the first p pairs from layout1 and the last n-p pairs from layout2 by looping through the lists
    kid <- matrix(nrow = nrow(layout1), ncol = 2)
    for (i in 1:p){
      kid[i,] <- layout1[i,]
    }
    for (i in (p+1):nrow(layout2)){
      kid[i,] <- layout2[i,]
    }
    return(kid)
  }
  
}

```

```{r}
#Testing the crossover function for n = 4, layout 1 is full of 1s, layout 2 is full of 0s, and p = 2
#binary rep: 
layout1 <- list()
layout2 <- list()
for (i in 1:4){
  layout1[[i]] <- c(1,1,1,1)
  layout2[[i]] <- 0
}
print("layout1")
vizualize_board(layout1, 4)
print("layout2")
vizualize_board(layout2, 4)
x1 <- crossover(layout1, layout2, 2)
print("Crossover of layout1 and layout2 on p = 2")
vizualize_board(x1, 4)
print("_____________________")
#singles rep:
layout3 <- as.integer(c(1,2,3,4))
layout4 <- as.integer(c(4,3,2,1))
print("layout3")
vizualize_board(layout3, 4)
print("layout4")
vizualize_board(layout4, 4)
x2 <- crossover(layout3, layout4, 2)
print("Crossover of layout3 and layout4 on p = 2")
vizualize_board(x2, 4)
print("_____________________")
#pairs rep:
layout5 <- matrix(as.integer(c(1,1,1,1,1,2,3,4)), nrow = 4, ncol = 2)
layout6 <- matrix(as.integer(c(4,4,4,4,1,2,3,4)), nrow = 4, ncol = 2)
print("layout5")
vizualize_board(layout5, 4)
print("layout6")
vizualize_board(layout6, 4)
x3 <- crossover(layout5, layout6, 2)
print("Crossover of layout5 and layout6 on p = 2")
vizualize_board(x3, 4)
```

### 3. 

Define the function mutate() that randomly moves a queen to a new position.

```{r 1.3}
#1.3
mutate <- function(layout,n){
  
  #Given a chessboard layout, returns a layout with a randomly moved queen
  
  if(typeof(layout) == "list" & is.null(ncol(layout))){
    #BINARY 
    print("Mut: Binary rep detected")
    #randomly flip a digit in a binary representation, and if it is not off the board
    #randomly select a 1 and change it to 0
    zero_coords <- c()
    for (i in 1:n){
      for (j in 1:n){
        if(layout[[i]][j] == 0){
          zero_coords <- c(zero_coords, i)
          zero_coords <- c(zero_coords, j)
        }
      }
    }
    
    rand_idx <- sample(length(zero_coords)/2, 1)
    x0 <- zero_coords[rand_idx*2]
    y0 <- zero_coords[rand_idx*2 + 1]
    
    one_coords <- c()
    for (i in 1:n){
      for (j in 1:n){
        if(layout[[i]][j] == 1){
          one_coords <- c(one_coords, i)
          one_coords <- c(one_coords, j)
        }
      }
    }
    #randomly select a 1 and change it to 0
    rand_idx <- sample(length(one_coords)/2, 1)
    x1 <- one_coords[1]
    y1 <- one_coords[2]
    
    new_layout <- layout
    new_layout[[x0]][y0] <- 1
    new_layout[[x1]][y1] <- 0
    
    #This approach has the risk of not changing the layout at all, but it is unlikely to happen as n get larger
    return(new_layout)
    
  }else if(typeof(layout) == "integer" & is.null(ncol(layout))){
    #SINGLES
    print("Mut: Singles rep detected")
    #randomly select a row and change the value of the number at this position, and check if the new queen is not on another queen , and if it is not off the board
    
    return(new_layout)
  }else if(typeof(layout) == "integer" & ncol(layout) == 2){
    #PAIRS (matrix)
    print("Mut: Pairs rep detected")
    #randomly select a row and a column and change the value of the pair at this position
    #check if the new queen is not on another queen , and if it is not off the board
    
    return(new_layout)
  }
}
```

```{r 1.3.test}
#Testing the mutate function for each representation
#binary rep:
layout1 <- list()
layout1[[1]] <- c(0,0,0,0)
layout1[[2]] <- c(0,1,0,0)
layout1[[3]] <- c(0,0,0,0)
layout1[[4]] <- c(0,0,0,0)
vizualize_board(layout1, 4)
mutated <- mutate(layout1, 4)
vizualize_board(mutated, 4)
#singles rep:

#pairs rep:
```

### 4. 

Define a fitness function for a given configuration. 
Experiment with three: 
1) binary — is a solution or not;
2) number of queens not attacked;
3) (nC2 - number) of pairs of queens attacking each other. 
If needed scale the value of the fitness function to [0, 1]. Experiment which could be the best one. Try each fitness function for each encoding method. You should not expect the binary fitness function to work well, explain why this is so.

```{r 1.4}
#1.1.4
fitness <- function(layout, fitness_function){
  #Given a chessboard layout, returns the fitness of the layout
  if(typeof(layout) == "list" & is.null(ncol(layout))){
    print("Fit: Binary rep detected")
    
  }else if(typeof(layout) == "integer" & is.null(ncol(layout))){
    print("Fit: Singles rep detected")
    
  }if(typeof(layout) == "integer" & ncol(layout) == 2){
    print("Fit: Pairs rep detected")
    
  }
  return(fitness)
}
```


### 5. 

Implement a genetic algorithm that takes the choice of encoding, mutation probability, and fitness function as parameters. Your implementation should start with a random initial configuration. Each element of the population should have its fitness calculated. Do not forget to have in your code a limit for the number of iterations (but this limit should not be lower than 100, unless this causes running time issues, which should be clearly presented then), so that your code does not run forever. Count the number of pairs of queens attacking each other. At each iteration :

* (a) Two individuals are randomly sampled from the current population, they are further used as parents (use sample()).
* (b) One individual with the smallest fitness is selected from the current population, this will be the victim (use order()).
* (c) The two sampled parents are to produce a kid by crossover, and this kid should be mutated with probability mutprob (use crossover(), mutate()).
* (d) The victim is replaced by the kid in the population.
* (e) Do not forget to update the vector of fitness values of the population.
* (f) Remember the number of pairs of queens attacking each other at the given iteration.

```{r 1.5}
#1.5
```

### 6. 

If found, return the legal configuration of queens.

```{r 1.6}
#1.6
```

### 7. 

Provide a plot of the number of pairs queens attacking each other at each iteration of the algorithm.

```{r 1.7}
#1.7
```

### 8. 

Run your code for n = 4, 8, 16 (if n = 16 requires too much computational time take a different n in {10, 11, 12, 13, 14, 15}, but do not forget that this is not a power of 2 and more care is needed in the second encoding), the different encodings, objective functions, and mutprob= 0.1, 0.5, 0.9. Did you find a legal state?

```{r 1.8}
#1.8
```

### 9. 

Discuss which encoding and objective function worked best.

```{r 1.9}
#1.9
```

________________
## Question 2: EM algorithm

The data file censoredproc.csv contains the time after which a certain product fails. Some of these measurements are left-censored (cens=2)—i.e., we did not observe the time of failure, only that the product had already failed when checked upon. Status cens=1 means that the exact time of failure was observed.

### 1. 

Plot a histogram of the values. Do it for all of the data, and also when the censored observations are removed. Do the histograms remind of an exponential distribution?

```{r 2.1}
#2.1 
```

### 2. 

Assume that the underlying data comes from an exponential distribution with parameter $\lambda$. This means that observed values come from the exponential $\lambda$ distribution, while censored from a truncated exponential distribution. Write down the likelihood function.

```{r 2.2}
#2.2
```

### 3. 

The goal now is to derive an EM algorithm that estimates $\lambda$. Based on the above found likelihood function, derive the EM algorithm for estimating $\lambda$. The formula in the M –step can be differentiated, but the derivative is non–linear in terms of $\lambda$ so its zero might need to be found numerically.

```{r 2.3}
#2.3
```

### 4. 

Implement the above in R. Take $\lambda_0 = 100$ as the starting value for the algorithm and stopping condition if the change in the estimate is less than 0.001. At what $\hat\lambda$ did the EM algorithm stop at? How many iterations were required?

```{r 2.4}
#2.4
```

### 5. 

Plot the density curve of the $exp(\hat\lambda)$ distribution over your histograms in task 1.

```{r 2.5}
#2.5
```

### 6. 

Study how good your EM algorithm is compared to usual maximum likelihood estimation with data reduced to only the uncensored observations. To this end we will use a parametric bootstrap. Repeat 1000 (reduce if computational time is too long—but carefully report the running times) times the following procedure:

* (a) Simulate the same number of data points as in the original data, from the exponential $\hat\lambda$ distribution.
* (b) Randomly select the same number of points as in the original data for censoring. For each observation for censoring—sample a new time from the uniform distribution on [0, true time]. Remember that the observation was censored.
* (c) Estimate $\lambda$ both by your EM-algorithm, and maximum likelihood based on the uncensored observations. Compare the distributions of the estimates of $\lambda$ from the two methods. Plot the histograms, report whether they both seem unbiased, and what is the variance of the estimators.

```{r 2.6}
#2.6

```

# Appendix

```{r appendix, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```