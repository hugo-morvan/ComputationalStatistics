---
title: "Lab 6"
author: "Hugo Morvan, Daniele Bozzoli"
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Question 1: Genetic algorithm


```{r vizualize function}
BinToDec <- function(x){
  #https://stackoverflow.com/questions/12892348/convert-binary-string-to-binary-or-decimal-value
  sum(2^(which(rev(unlist(strsplit(as.character(x), "")) == 1))-1))
}

vizualize_board <- function(layout, n){
  #Given a layout, vizualizes the board
  if(typeof(layout) == "list" & is.null(ncol(layout))){
    #print("Binary")
    #Binary
    board <- matrix(nrow = n, ncol = n)
    #fill the board with 0s
    for (i in 1:nrow(board)){
      for (j in 1:ncol(board)){
        board[i,j] <- 0
      }
    }
    for (i in 1:n){
      board[i,BinToDec(layout[[i]])] <- 1
    }
    board <- t(board)
    #print(board)
  }else if(typeof(layout) == "integer" & is.null(ncol(layout))){
    #print("Singles")
    #Singles
    #fill the board with 0s
    board <- matrix(nrow = n, ncol = n)
    for (i in 1:n){
      for (j in 1:n){
        board[i,j] <- 0
      }
    }
    for (i in 1:n){
      board[i,layout[i]] <- 1
    }
    board <- t(board)
    #print(board)
  }else{
    #Pairs
    #print("Pairs")
    board <- matrix(nrow = n, ncol = n)
    #fill the board with 0s
    for (i in 1:nrow(board)){
      for (j in 1:ncol(board)){
        board[i,j] <- 0
      }
    }
    for (i in 1:nrow(layout)){
      board[layout[i,1], layout[i,2]] <- 1
    }
  }
  #Print the board in the console:
  for (i in 1:(nrow(board)*2)){
    cat("_")
  }
  cat("\n")
  for (i in 1:nrow(board)){
    cat("|")
    for (j in 1:ncol(board)){
      if(board[i,j] == 0){
        cat(" |")
      }else{
        cat("Q|")
      }
    }
    cat("\n")
  }
}
```

## Pairs Encoding

```{r Pairs Representation, echo=TRUE}
#################### PAIRS REPRESENTATION ####################

# Question 2 : Crossover

crossover <- function(layout1, layout2, p){
  #PAIRS (matrix)
  kid <- matrix(nrow = nrow(layout1), ncol = 2)
  for (i in 1:p){
    kid[i,] <- layout1[i,]
  }
  for (i in (p+1):nrow(layout2)){
    kid[i,] <- layout2[i,]
  }
  return(kid)
}

# Question 3 : Mutate

mutate <- function(layout,n){
  pair <- sample(n,1)
  layout[pair,1] <- sample(n,1)
  layout[pair,2] <- sample(n,1)
  #Disadvantages of this layout : can move to a location where there is already a queen 
  # --> Good or bad ? Good: simulate a queen "disappearing", bad: duplicates in the representation
  return(layout)
}

# Question 4 : Fitness

fitness <- function(layout, fitness_function, n){
  board <- matrix(nrow = n, ncol = n)
  #fill the board with 0s
  for (i in 1:n){
    for (j in 1:n){
      board[i,j] <- 0
    }
  }
  #fill the board with 1s where there are queens
  for (i in 1:n){
    board[layout[i,1], layout[i,2]] <- 1
  }
  #================================================================================
 #Convert the board to a list of coordinates 
  my_vec <- c()
  for(i in 1:n){
    for(j in 1:n){
      if(board[i,j]==1){
        my_vec <- c(my_vec, c(i,j))
      }
    }
  }
  if(length(my_vec) == 0){
    return(0)
  }
  points<-array( my_vec, dim=c(2,length(my_vec)/2))
  are_attacking_eachother <- function(Q1,Q2){
    #https://stackoverflow.com/questions/57239548/how-to-check-if-a-queen-is-under-attack-in-nqueens
    (Q1[1] == Q2[1] | Q1[2] == Q2[2] | Q1[1]-Q1[2] == Q2[1]-Q2[2] | Q1[1]+Q1[2] == Q2[1]+Q2[2])
  }
  fitness <- 0
  if(length(points)/2 == 1){
    if(fitness_function == "binary"){
      return(0)
    }else if(fitness_function == "num_safe"){
      return(1)
    }else{
      #number of attacking pairs
      return(0)
    }
  }else if(fitness_function == "binary"){
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
  }else if(fitness_function == "num_safe"){
    safe <- 0
     for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(!are_attacking_eachother(Q1, Q2)){
            safe <- safe + 2
          }
        } 
     }
    #to scale to [0,1], we could divide by the max number of queens that can be safe
    fitness <- safe
  }else if(fitness_function == "num_attacking"){
    num_attacking <- 0
    for(queen in 1:((length(points)/2)-1)){
      for(other_queen in (queen+1):(length(points)/2)){
        Q1 <- c(points[1,queen], points[2,queen])
        Q2 <- c(points[1,other_queen], points[2,other_queen])
        if(are_attacking_eachother(Q1, Q2)){
          num_attacking <- num_attacking + 1
        }
      } 
    }
    fitness <- num_attacking
  }else{
      #(nC2 - number) of pairs of queens attacking each other.
      nc2 <- (n*(n-1)/2)
      num_attacking <- 0
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
      fitness <- (nc2 - num_attacking)
  }
  return(fitness)
}

# Question 5 : Genetic Algorithm

generate_random_layout_pairs <- function(n){
  pairs<-array(0, dim=c(n,2))
  for (i in 1:n){
    pairs[i,1] <- sample(n,1)
    pairs[i,2] <- sample(n,1)
  }
  return(pairs)
}

darwin_pairs <- function(n_generations, board_size, n_population, mutprob, fitness_function, crossover_p){
  ###### Initialization ######
  #generate random population
  population <- list()
  for(i in 1:n_population){
    population[[i]] <- generate_random_layout_pairs(board_size)
  }

  #calculate fitness of population
  fitnesses <- c()
  for(i in 1:n_population){
    fitnesses[i] <- fitness(population[[i]], fitness_function, board_size)
  }
  n_attacking_queens <- c()
  solutions <- list()
  ###### Genetic Algorithm ######
  for(generation in 1:n_generations){

    #Two individuals are randomly sampled from the current population, 
    # they are further used as parents
    parents <- sample(population, 2, replace = FALSE)

    #One individual with the smallest fitness is selected from the current population,
    # this will be the victim
    victim <- population[which.min(fitnesses)]
    victim_idx <- which.min(fitnesses)
    #The two sampled parents are to produce a kid by crossover
    kid <- crossover(parents[[1]], parents[[2]], p=crossover_p)

    #this kid should be mutated with probability mutprob
    if(runif(1) < mutprob){
      kid <- mutate(kid, board_size)
    }

    #The victim is replaced by the kid in the population
    population[[victim_idx]] <- kid

    #Do not forget to update the vector of fitness values of the population
    fitnesses[victim_idx] <- fitness(kid, fitness_function, board_size)

    #Remember the number of pairs of queens attacking each other at the given iteration
    attacking_queens <- 0
    for(i in 1:n_population){
      attacking_queens <- attacking_queens + fitness(population[[i]], "num_attacking", board_size)
      if(fitness(population[[i]], "num_attacking", board_size) == 0){
        solutions[[length(solutions)+1]] <- population[[i]]
      }
    }
    n_attacking_queens <- c(n_attacking_queens, attacking_queens)

  }
  return(list(n_attacking_queens = n_attacking_queens, solutions = solutions))
}

```

### 6. 

If found, return the legal configuration of queens.

```{r pairs.6}
# Question 6 : Legal Configuration
res_pairs <- darwin_pairs(n_generations = 1000, 
                          board_size =  4, 
                          n_population = 20, 
                          mutprob = 0.1, 
                          fitness_function = "num_safe",
                          crossover_p = 2)

cat("found", length(res_pairs$solutions), "legal configurations \n")
cat("Example of a legal configuration : \n")
if(length(res_pairs$solutions) > 0){
  vizualize_board(res_pairs$solutions[[1]], 4)
}
```


### 7. 

Provide a plot of the number of pairs queens attacking each other at each iteration of the algorithm.

```{r pairs.7}
# Question 7 : Plot
plot(res_pairs$n_attacking_queens, type="l", xlab="Generation", ylab="Number of attacking queens")
title("Number of attacking queens at each generation on a 4x4 board \n (pairs encoding)")

```

## Binary Encoding

```{r Binary Representation , echo=TRUE}
################### Binary Representation ###################

# Question 2 : Crossover

crossover <- function(layout1, layout2, p){
  #p < log2(n)/2
  kid <- list()
  for (i in 1:p){
    kid[[i]] <- layout1[[i]]
  }
  for (i in (p+1):length(layout2)){
    kid[[i]] <- layout2[[i]]
  }
  return(kid)
}

# Question 3 : Mutate

mutate <- function(layout,n){
    #randomly select a binary string
    binary_string <- sample(1:length(layout), 1)
    #randomly select a bit in the binary string
    bit <- sample(1:length(layout[[binary_string]]), 1)
    #flip the bit
    layout[[binary_string]][bit] <- abs(layout[[binary_string]][bit] - 1)
    return(layout)
}

# Question 4 : Fitness

fitness <- function(layout, fitness_function, n){
  #Very twisted and inefficient way of doing things, to be modified
  board <- matrix(nrow = n, ncol = n)
  #fill the board with 0s
  for (i in 1:nrow(board)){
    for (j in 1:ncol(board)){
      board[i,j] <- 0
    }
  }
  for (i in 1:length(layout)){
    board[i, BinToDec(layout[[i]])] <- 1
  }
  board <- t(board) 

  #================================================================================
  #At this point, the board var should contain a matrix on the state of the board, with 1s for queens and 0s for empty spaces
  #Convert the board to a list of coordinates 
  my_vec <- c()
  for(i in 1:n){
    for(j in 1:n){
      if(board[i,j]==1){
        my_vec <- c(my_vec, c(i,j))
      }
    }
  }
  if(length(my_vec) == 0){
    return(0)
  }
  points<-array( my_vec, dim=c(2,length(my_vec)/2))
  are_attacking_eachother <- function(Q1,Q2){
    #https://stackoverflow.com/questions/57239548/how-to-check-if-a-queen-is-under-attack-in-nqueens
    (Q1[1] == Q2[1] | Q1[2] == Q2[2] | Q1[1]-Q1[2] == Q2[1]-Q2[2] | Q1[1]+Q1[2] == Q2[1]+Q2[2])
  }
  fitness <- 0
  #If only one queen on the board:
  if(length(points)/2 <= 1){
    if(fitness_function == "binary"){
      return(0)
    }else if(fitness_function == "num_safe"){
      return(length(points)/2)
    }else{ #number of attacking pairs
      return(0)
    }
    
  }else if(fitness_function == "binary"){
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
  }else if(fitness_function == "num_safe"){
    safe <- 0
     for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(!are_attacking_eachother(Q1, Q2)){
            safe <- safe + 2
          }
        } 
     }
    #to scale to [0,1], we can divide by the max number of queens that can be safe
    fitness <- safe
    
  }else if(fitness_function == "num_attacking"){
    num_attacking <- 0
    for(queen in 1:((length(points)/2)-1)){
      for(other_queen in (queen+1):(length(points)/2)){
        Q1 <- c(points[1,queen], points[2,queen])
        Q2 <- c(points[1,other_queen], points[2,other_queen])
        if(are_attacking_eachother(Q1, Q2)){
          num_attacking <- num_attacking + 1
        }
      } 
    }
    fitness <- num_attacking
  }else{
      #(nC2 - number) of pairs of queens attacking each other.
      nc2 <- (n*(n-1)/2)
      num_attacking <- 0
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
      fitness <- nc2 - num_attacking
  }
  return(fitness)
}

# Question 5 : Genetic Algorithm

generate_random_layout_binary <- function(n){
  #Only works for n powers of 2, otherwise it can produces queens outside of the board
  layout <- list()
  for (i in 1:n){
    layout[[i]] <- sample(0:1, ceiling(log2(n)), replace = TRUE)
  }
  return(layout)
}

darwin_bin <- function(n_generations, board_size, n_population, mutprob, fitness_function, crossover_p){

  #generate random population
  population <- list()
  for(i in 1:n_population){
    population[[i]] <- generate_random_layout_binary(board_size)
  }

  #calculate fitness of population
  fitnesses <- c()
  for(i in 1:n_population){
    fitnesses[i] <- fitness(population[[i]], fitness_function, board_size)
  }
  n_attacking_queens <- c()
  solutions <- list()
  ###### Genetic Algorithm ######
  for(generation in 1:n_generations){
    #Two individuals are randomly sampled from the current population, they are further used as parents
    parents <- sample(population, 2, replace = FALSE)

    #One individual with the smallest fitness is selected from the current population, this will be the victim
    victim <- population[which.min(fitnesses)][[1]]
    victim_idx <- which.min(fitnesses)

    #The two sampled parents are to produce a kid by crossover
    kid <- crossover(parents[[1]], parents[[2]], p=crossover_p)
    #this kid should be mutated with probability mutprob
    if(runif(1) < mutprob){
      kid <- mutate(kid, board_size)
    }
    #The victim is replaced by the kid in the population
  
    population[[victim_idx]] <- kid

    #Do not forget to update the vector of fitness values of the population
    fitnesses[victim_idx] <- fitness(kid, fitness_function, board_size)

  #Remember the number of pairs of queens attacking each other at the given iteration
    attacking_queens <- 0
    for(i in 1:n_population){
      attacking_queens <- attacking_queens + fitness(population[[i]], "num_attacking", board_size)
      if(fitness(population[[i]], "num_attacking", board_size) == 0){
        solutions[[length(solutions)+1]] <- population[[i]]
      }
    }
    n_attacking_queens <- c(n_attacking_queens, attacking_queens)

  }
  return(list(n_attacking_queens = n_attacking_queens, solutions = solutions))
}

```

### 6. 

If found, return the legal configuration of queens.

```{r bin.6}
# Question 6 : Legal Configuration
res_bin <- darwin_bin(n_generations = 1000, 
                          board_size =  4, 
                          n_population = 20, 
                          mutprob = 0.1, 
                          fitness_function = "num_safe",
                          crossover_p = 1) #Bin rep so 2bits only

cat("found", length(res_bin$solutions), "legal configurations \n")
cat("Example of a legal configuration : \n")
if(length(res_bin$solutions) > 0){
  vizualize_board(res_bin$solutions[[1]], 4)
}
```


### 7. 

Provide a plot of the number of pairs queens attacking each other at each iteration of the algorithm.

```{r bin.7}
# Question 7 : Plot
plot(res_bin$n_attacking_queens, type="l", xlab="Generation", ylab="Number of attacking queens")
title("Number of attacking queens at each generation on a 4x4 board \n (binary encoding)")

```


## Singles Encoding

```{r Singles Representation , echo=TRUE}
################### Singles Representation ###################

# Question 2 : Crossover

crossover <- function(layout1, layout2, p){
  kid <- c()
    for (i in 1:p){
      kid <- c(kid , layout1[i])
    }
    for (i in (p+1):length(layout2)){
      kid <- c(kid , layout2[i])
    }
    return(kid)
}

# Question 3 : Mutate

mutate <- function(layout,n){
    row <- sample(n,1)
    layout[row] <- sample(n,1)
    #Disadvantages of this method : a queen can only be moved within a column, and it can also not be moved at all
    return(layout)
}

# Question 4 : Fitness

fitness <- function(layout, fitness_function, n){
  #Very twisted and inefficient way of doing things, to be modified
  board <- matrix(nrow = n, ncol = n)
  #fill the board with 0s
  for (i in 1:n){
    for (j in 1:n){
      board[i,j] <- 0
    }
  }
  for (i in 1:n){
    board[i,layout[i]] <- 1
  }
  board <- t(board)
  #================================================================================
  #At this point, the board var should contain a matrix on the state of the board, with 1s for queens and 0s for empty spaces
  #Convert the board to a list of coordinates 
  my_vec <- c()
  for(i in 1:n){
    for(j in 1:n){
      if(board[i,j]==1){
        my_vec <- c(my_vec, c(i,j))
      }
    }
  }
  if(length(my_vec) == 0){
    return(0)
  }
  points<-array( my_vec, dim=c(2,length(my_vec)/2))
  are_attacking_eachother <- function(Q1,Q2){
    #https://stackoverflow.com/questions/57239548/how-to-check-if-a-queen-is-under-attack-in-nqueens
    (Q1[1] == Q2[1] | Q1[2] == Q2[2] | Q1[1]-Q1[2] == Q2[1]-Q2[2] | Q1[1]+Q1[2] == Q2[1]+Q2[2])
  }
  fitness <- 0
  #If only one queen on the board:
  if(length(points)/2 <= 1){
    if(fitness_function == "binary"){
      return(0)
    }else if(fitness_function == "num_safe"){
      return(length(points)/2)
    }else{ #number of attacking pairs
      return(0)
    }
  }else if(fitness_function == "binary"){
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
  }else if(fitness_function == "num_safe"){
    safe <- 0
     for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(!are_attacking_eachother(Q1, Q2)){
            safe <- safe + 2
          }
        } 
     }
    #to scale to [0,1], we can divide by the max number of queens that can be safe
    fitness <- safe
  }else if(fitness_function == "num_attacking"){
    num_attacking <- 0
    for(queen in 1:((length(points)/2)-1)){
      for(other_queen in (queen+1):(length(points)/2)){
        Q1 <- c(points[1,queen], points[2,queen])
        Q2 <- c(points[1,other_queen], points[2,other_queen])
        if(are_attacking_eachother(Q1, Q2)){
          num_attacking <- num_attacking + 1
        }
      } 
    }
    fitness <- num_attacking
  }else{
      #(nC2 - number) of pairs of queens attacking each other.
      nc2 <- (n*(n-1)/2)
      num_attacking <- 0
      for(queen in 1:((length(points)/2)-1)){
        for(other_queen in (queen+1):(length(points)/2)){
          Q1 <- c(points[1,queen], points[2,queen])
          Q2 <- c(points[1,other_queen], points[2,other_queen])
          if(are_attacking_eachother(Q1, Q2)){
            fitness <- 1
          }
        } 
      }
      fitness <- (nc2 - num_attacking)
  }
  return(fitness)
}

# Question 5 : Genetic Algorithm

generate_random_layout_singles <- function(n){
  layout <- c()
  for (i in 1:n){
    layout[i] <- sample(1:n,1)
  }
  return(layout)
}

darwin_singles <- function(n_generations, board_size, n_population, mutprob, fitness_function, crossover_p){

  #generate random population
  population <- list()
  for(i in 1:n_population){
    population[[i]] <- generate_random_layout_singles(board_size)
  }

  #calculate fitness of population
  fitnesses <- c()
  for(i in 1:n_population){
    fitnesses[i] <- fitness(population[[i]], fitness_function, board_size)
  }
  n_attacking_queens <- c()
  solutions <- list()
  ###### Genetic Algorithm ######
  for(generation in 1:n_generations){
    #Two individuals are randomly sampled from the current population, they are further used as parents
    parents <- sample(population, 2, replace = FALSE)

    #One individual with the smallest fitness is selected from the current population, this will be the victim
    victim <- population[which.min(fitnesses)][[1]]
    victim_idx <- which.min(fitnesses)

    #The two sampled parents are to produce a kid by crossover
    kid <- crossover(parents[[1]], parents[[2]], p=crossover_p)
    #this kid should be mutated with probability mutprob
    if(runif(1) < mutprob){
      kid <- mutate(kid, board_size)
    }
    #The victim is replaced by the kid in the population
  
    population[[victim_idx]] <- kid

    #Do not forget to update the vector of fitness values of the population
    fitnesses[victim_idx] <- fitness(kid, fitness_function, board_size)

  #Remember the number of pairs of queens attacking each other at the given iteration
    attacking_queens <- 0
    for(i in 1:n_population){
      attacking_queens <- attacking_queens + fitness(population[[i]], "num_attacking", board_size)
      if(fitness(population[[i]], "num_attacking", board_size) == 0){
        solutions[[length(solutions)+1]] <- population[[i]]
      }
    }
    n_attacking_queens <- c(n_attacking_queens, attacking_queens)
  }
  return(list(n_attacking_queens = n_attacking_queens, solutions = solutions))
}

```

### 6. 

If found, return the legal configuration of queens.

```{r sin.6}
# Question 6 : Legal Configuration
res_sin <- darwin_singles(n_generations = 1000,
                          board_size = 4,
                          n_population = 20,
                          mutprob = 0.1,
                          fitness_function ="num_safe",
                          crossover_p = 2)

cat("found", length(res_sin$solutions), "legal configurations \n")
cat("Example of a legal configuration : \n")
if(length(res_sin$solutions) > 0){
  vizualize_board(res_sin$solutions[[1]], 4)
}
```

### 7. 

Provide a plot of the number of pairs queens attacking each other at each iteration of the algorithm.

```{r sin.7}
# Question 7 : Plot
plot(res_sin$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 4x4 board \n (singles encoding)")
```

### 8. 

Run your code for n = 4, 8, 16 , the different encodings, objective functions, and mutprob= 0.1, 0.5, 0.9. Did you find a legal state?

### Testing Different board sizes : 

```{r 1.8.n}

# n = 4
start_time <- Sys.time()
res_sin4 <- darwin_singles(n_generations = 500,
                           board_size = 4,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "num_safe",
                           crossover_p = 2)
end_time <- Sys.time()

cat("N = 4 : found", length(res_sin4$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sin4$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 4x4 board \n (singles encoding)")

# n = 8
start_time <- Sys.time()
res_sin8 <- darwin_singles(n_generations = 500,
                           board_size = 8,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "num_safe",
                           crossover_p = 4)
end_time <- Sys.time()

cat("N = 8 : found", length(res_sin8$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sin8$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (singles encoding)")

# n = 16
start_time <- Sys.time()
res_sin16 <- darwin_singles(n_generations = 500,
                           board_size = 16,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "num_safe",
                           crossover_p = 8)
end_time <- Sys.time()

cat("N = 16 : found", length(res_sin16$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sin4$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 16x16 board \n (singles encoding)")

```

### Testing Different fitness functions : 

```{r 1.8.fitness}

# Binary
start_time <- Sys.time()
res_sinA <- darwin_singles(n_generations = 500,
                           board_size = 8,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "binary",
                           crossover_p = 4)
end_time <- Sys.time()

cat("Binary: found", length(res_sinA$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinA$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (binary fitness)")

# Number of Safe Queens
start_time <- Sys.time()
res_sinB <- darwin_singles(n_generations = 500,
                           board_size = 8,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "num_safe",
                           crossover_p = 4)
end_time <- Sys.time()

cat("Num_safe : found", length(res_sinB$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinB$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (Num_safe fitness)")

# n = 16
start_time <- Sys.time()
res_sinC <- darwin_singles(n_generations = 500,
                           board_size = 8,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "other",
                           crossover_p = 4)
end_time <- Sys.time()

cat("nC2 - num_attacking : found", length(res_sinC$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinC$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (nC2 - num_attacking fitness)")

```

### Testing Different mutation probabilities : 

```{r 1.8.mutation}

# mutprob= 0.1
start_time <- Sys.time()
res_sinA <- darwin_singles(n_generations = 1000,
                           board_size = 8,
                           n_population = 20,
                           mutprob =0.1,
                           fitness_function = "num_safe",
                           crossover_p = 4)
end_time <- Sys.time()

cat("mutprob= 0.1: found", length(res_sinA$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinA$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (mutprob= 0.1)")

# mutprob= 0.5
start_time <- Sys.time()
res_sinB <- darwin_singles(n_generations = 1000,
                           board_size = 8,
                           n_population = 20,
                           mutprob= 0.5,
                           fitness_function = "num_safe",
                           crossover_p = 4)
end_time <- Sys.time()

cat("mutprob= 0.5: found", length(res_sinB$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinB$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (mutprob= 0.5)")

# mutprob= 0.9
start_time <- Sys.time()
res_sinC <- darwin_singles(n_generations = 1000,
                           board_size = 8,
                           n_population = 20,
                           mutprob= 0.9,
                           fitness_function = "num_safe",
                           crossover_p = 4)
end_time <- Sys.time()

cat("mutprob= 0.9: found", length(res_sinC$solutions), "legal configurations")
cat("\n")
cat("time taken:", end_time - start_time, "seconds")
cat("\n")
plot(res_sinC$n_attacking_queens, type = "l", xlab = "Generation", ylab = "Number of attacking queens")
title("Number of attacking queens at each generation on a 8x8 board \n (mutprob= 0.9)")

```
The mutation probability seems the affect the "smoothness" of the graph. This is probably due to the fact that improvement is made when a new (good) layout is introduced into the population, and this is more likely to happen when the mutation probability is higher.

### 9. 

Discuss which encoding and objective function worked best.

The way we coded this assignment, the singles encoding seems to be working the best as it shows the most consistent improvement over the generations. The binary encoding, although computationally friendlier, shows a more erratic behavior. The pairs encoding is flawed by nature because it introduces unwanted behaviors.
The number of safe queens fitness function seems to be the best one in our case. The binary fitness function is not good at all because it does not give any information about the quality of a solution, which is necessary for the genetic algorithm to perform well. The nC2 - num_attacking fitness function did not seem to work well, but it could be due to a design problem in our fitness function. 

________________
# Question 2: EM algorithm

### 1. 

Plot a histogram of the values. Do it for all of the data, and also when the censored observations are removed. Do the histograms remind of an exponential distribution?

```{r 2.1}
# 2.1
data <- read.csv2("censoredproc.csv")

par(mfrow=c(1,3))

# histogram of all data
hist(as.numeric(data[,1]), freq=F, main="Histogram of all data")

# histogram of data with cens=1
hist(as.numeric(data[which(data[,2]==1),1]), freq=F, main="Histogram of cens=1 data")

# histogram of data with cens=2
hist(as.numeric(data[which(data[,2]==2),1]), freq=F, main="Histogram of cens=2 data")

min(as.numeric(data[which(data[,2]==1),1]))
min(as.numeric(data[which(data[,2]==2),1]))

```
Yes, they both look like exponential distributions.

### 2. 

Assume that the underlying data comes from an exponential distribution with parameter $\lambda$. This means that observed values come from the exponential $\lambda$ distribution, while censored from a truncated exponential distribution. Write down the likelihood function.

Let's now assume that all uncensored observations are exponentially distributed with density $f(x) = \lambda e^{-\lambda x}$, and let's also assume (although it is very unlikely to be the case, looking at the previous histograms) that censored data are following a truncated exponential distribution.
Let's try compute the likelihood of our data. With the previous assumptions, it is reasonable to say that the truncated exponential distribution limits the original exponential distribution to the interval $[a, b]$ with $0 <a \leq b$. Furthermore we add a dummy variable $\gamma_i$ that is equal to 0 if the observation $x_i$ is uncensored and is equal to 1 if it is censored.

Likelihood function:

$$L(\lambda) = \prod_{i=1}^n f(x_i)^{(1-\gamma_i)} \cdot \Bigg( \frac{f(x_i)}{F(b) - F(a)} \Bigg) ^{\gamma_i}$$.


### 3. 

The goal now is to derive an EM algorithm that estimates $\lambda$. Based on the above found likelihood function, derive the EM algorithm for estimating $\lambda$. The formula in the M –step can be differentiated, but the derivative is non–linear in terms of $\lambda$ so its zero might need to be found numerically.

```{r 2.3}
#2.3
```

### 4. 

Implement the above in R. Take $\lambda_0 = 100$ as the starting value for the algorithm and stopping condition if the change in the estimate is less than 0.001. At what $\hat\lambda$ did the EM algorithm stop at? How many iterations were required?

```{r 2.4}
#2.4
```

### 5. 

Plot the density curve of the $exp(\hat\lambda)$ distribution over your histograms in task 1.

```{r 2.5}
#2.5
```

### 6. 

Study how good your EM algorithm is compared to usual maximum likelihood estimation with data reduced to only the uncensored observations. To this end we will use a parametric bootstrap. Repeat 1000 (reduce if computational time is too long—but carefully report the running times) times the following procedure:

* (a) Simulate the same number of data points as in the original data, from the exponential $\hat\lambda$ distribution.
* (b) Randomly select the same number of points as in the original data for censoring. For each observation for censoring—sample a new time from the uniform distribution on [0, true time]. Remember that the observation was censored.
* (c) Estimate $\lambda$ both by your EM-algorithm, and maximum likelihood based on the uncensored observations. Compare the distributions of the estimates of $\lambda$ from the two methods. Plot the histograms, report whether they both seem unbiased, and what is the variance of the estimators.

```{r 2.6}
#2.6

```

# Appendix

```{r appendix, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```